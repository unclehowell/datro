{"version":3,"sources":["webpack:///./tracing.js"],"names":["length","a","b","Math","sqrt","isOnSegment","c","const","lengthAc","lengthAb","dot","abs","mod","getPartialRingCoords","feature","startPoint","endPoint","let","polygon","getGeometry","getType","getPolygon","i","pointA","pointB","ringCoords","getLinearRing","getCoordinates","startSegmentIndex","cwCoordinates","cwLength","ccwCoordinates","ccwLength","push","drawInteraction","tracingFeature","raster","source","baseVector","format","url","drawVector","style","stroke","color","width","fill","previewLine","geometry","previewVector","features","map","layers","target","view","center","zoom","drawing","getFeatureOptions","hitTolerance","layerFilter","layer","on","event","hit","forEachFeatureAtPixel","pixel","coord","getCoordinateFromPixel","getClosestPoint","appendCoords","removeLastPoint","appendCoordinates","setCoordinates","previewCoords","snapInteraction","getSource","typeSelect","document","getElementById","addInteraction","value","type","onchange","removeInteraction"],"mappings":"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","file":"tracing.js","sourcesContent":["import Draw from '../src/ol/interaction/Draw.js';\nimport Feature from '../src/ol/Feature.js';\nimport Fill from '../src/ol/style/Fill.js';\nimport GeoJSON from '../src/ol/format/GeoJSON.js';\nimport LineString from '../src/ol/geom/LineString.js';\nimport Map from '../src/ol/Map.js';\nimport Snap from '../src/ol/interaction/Snap.js';\nimport Stroke from '../src/ol/style/Stroke.js';\nimport Style from '../src/ol/style/Style.js';\nimport View from '../src/ol/View.js';\nimport {OSM, Vector as VectorSource} from '../src/ol/source.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\n\n// math utilities\n\n// coordinates; will return the length of the [a, b] segment\nfunction length(a, b) {\n  return Math.sqrt(\n    (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])\n  );\n}\n\n// coordinates; will return true if c is on the [a, b] segment\nfunction isOnSegment(c, a, b) {\n  const lengthAc = length(a, c);\n  const lengthAb = length(a, b);\n  const dot =\n    ((c[0] - a[0]) * (b[0] - a[0]) + (c[1] - a[1]) * (b[1] - a[1])) / lengthAb;\n  return Math.abs(lengthAc - dot) < 1e-6 && lengthAc < lengthAb;\n}\n\n// modulo for negative values, eg: mod(-1, 4) returns 3\nfunction mod(a, b) {\n  return ((a % b) + b) % b;\n}\n\n// returns a coordinates array which contains the segments of the feature's\n// outer ring between the start and end points\n// Note: this assumes the base feature is a single polygon\nfunction getPartialRingCoords(feature, startPoint, endPoint) {\n  let polygon = feature.getGeometry();\n  if (polygon.getType() === 'MultiPolygon') {\n    polygon = polygon.getPolygon(0);\n  }\n  const ringCoords = polygon.getLinearRing().getCoordinates();\n\n  let i,\n    pointA,\n    pointB,\n    startSegmentIndex = -1;\n  for (i = 0; i < ringCoords.length; i++) {\n    pointA = ringCoords[i];\n    pointB = ringCoords[mod(i + 1, ringCoords.length)];\n\n    // check if this is the start segment dot product\n    if (isOnSegment(startPoint, pointA, pointB)) {\n      startSegmentIndex = i;\n      break;\n    }\n  }\n\n  const cwCoordinates = [];\n  let cwLength = 0;\n  const ccwCoordinates = [];\n  let ccwLength = 0;\n\n  // build clockwise coordinates\n  for (i = 0; i < ringCoords.length; i++) {\n    pointA =\n      i === 0\n        ? startPoint\n        : ringCoords[mod(i + startSegmentIndex, ringCoords.length)];\n    pointB = ringCoords[mod(i + startSegmentIndex + 1, ringCoords.length)];\n    cwCoordinates.push(pointA);\n\n    if (isOnSegment(endPoint, pointA, pointB)) {\n      cwCoordinates.push(endPoint);\n      cwLength += length(pointA, endPoint);\n      break;\n    } else {\n      cwLength += length(pointA, pointB);\n    }\n  }\n\n  // build counter-clockwise coordinates\n  for (i = 0; i < ringCoords.length; i++) {\n    pointA = ringCoords[mod(startSegmentIndex - i, ringCoords.length)];\n    pointB =\n      i === 0\n        ? startPoint\n        : ringCoords[mod(startSegmentIndex - i + 1, ringCoords.length)];\n    ccwCoordinates.push(pointB);\n\n    if (isOnSegment(endPoint, pointA, pointB)) {\n      ccwCoordinates.push(endPoint);\n      ccwLength += length(endPoint, pointB);\n      break;\n    } else {\n      ccwLength += length(pointA, pointB);\n    }\n  }\n\n  // keep the shortest path\n  return ccwLength < cwLength ? ccwCoordinates : cwCoordinates;\n}\n\n// layers definition\n\nconst raster = new TileLayer({\n  source: new OSM(),\n});\n\n// features in this layer will be snapped to\nconst baseVector = new VectorLayer({\n  source: new VectorSource({\n    format: new GeoJSON(),\n    url:\n      \"https://ahocevar.com/geoserver/wfs?service=wfs&request=getfeature&typename=topp:states&cql_filter=STATE_NAME='Idaho'&outputformat=application/json\",\n  }),\n});\n\n// this is were the drawn features go\nconst drawVector = new VectorLayer({\n  source: new VectorSource(),\n  style: new Style({\n    stroke: new Stroke({\n      color: 'rgba(100, 255, 0, 1)',\n      width: 2,\n    }),\n    fill: new Fill({\n      color: 'rgba(100, 255, 0, 0.3)',\n    }),\n  }),\n});\n\n// this line only appears when we're tracing a feature outer ring\nconst previewLine = new Feature({\n  geometry: new LineString([]),\n});\nconst previewVector = new VectorLayer({\n  source: new VectorSource({\n    features: [previewLine],\n  }),\n  style: new Style({\n    stroke: new Stroke({\n      color: 'rgba(255, 0, 0, 1)',\n      width: 2,\n    }),\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, baseVector, drawVector, previewVector],\n  target: 'map',\n  view: new View({\n    center: [-12986427, 5678422],\n    zoom: 5,\n  }),\n});\n\nlet drawInteraction, tracingFeature, startPoint, endPoint;\nlet drawing = false;\n\nconst getFeatureOptions = {\n  hitTolerance: 10,\n  layerFilter: (layer) => {\n    return layer === baseVector;\n  },\n};\n\n// the click event is used to start/end tracing around a feature\nmap.on('click', (event) => {\n  if (!drawing) {\n    return;\n  }\n\n  let hit = false;\n  map.forEachFeatureAtPixel(\n    event.pixel,\n    (feature) => {\n      if (tracingFeature && feature !== tracingFeature) {\n        return;\n      }\n\n      hit = true;\n      const coord = map.getCoordinateFromPixel(event.pixel);\n\n      // second click on the tracing feature: append the ring coordinates\n      if (feature === tracingFeature) {\n        endPoint = tracingFeature.getGeometry().getClosestPoint(coord);\n        const appendCoords = getPartialRingCoords(\n          tracingFeature,\n          startPoint,\n          endPoint\n        );\n        drawInteraction.removeLastPoint();\n        drawInteraction.appendCoordinates(appendCoords);\n        tracingFeature = null;\n      }\n\n      // start tracing on the feature ring\n      tracingFeature = feature;\n      startPoint = tracingFeature.getGeometry().getClosestPoint(coord);\n    },\n    getFeatureOptions\n  );\n\n  if (!hit) {\n    // clear current tracing feature & preview\n    previewLine.getGeometry().setCoordinates([]);\n    tracingFeature = null;\n  }\n});\n\n// the pointermove event is used to show a preview of the result of the tracing\nmap.on('pointermove', (event) => {\n  if (tracingFeature && drawing) {\n    let coord = null;\n    map.forEachFeatureAtPixel(\n      event.pixel,\n      (feature) => {\n        if (tracingFeature === feature) {\n          coord = map.getCoordinateFromPixel(event.pixel);\n        }\n      },\n      getFeatureOptions\n    );\n\n    let previewCoords = [];\n    if (coord) {\n      endPoint = tracingFeature.getGeometry().getClosestPoint(coord);\n      previewCoords = getPartialRingCoords(\n        tracingFeature,\n        startPoint,\n        endPoint\n      );\n    }\n    previewLine.getGeometry().setCoordinates(previewCoords);\n  }\n});\n\nconst snapInteraction = new Snap({\n  source: baseVector.getSource(),\n});\n\nconst typeSelect = document.getElementById('type');\n\nfunction addInteraction() {\n  const value = typeSelect.value;\n  if (value !== 'None') {\n    drawInteraction = new Draw({\n      source: drawVector.getSource(),\n      type: typeSelect.value,\n    });\n    drawInteraction.on('drawstart', () => {\n      drawing = true;\n    });\n    drawInteraction.on('drawend', () => {\n      drawing = false;\n      previewLine.getGeometry().setCoordinates([]);\n      tracingFeature = null;\n    });\n    map.addInteraction(drawInteraction);\n    map.addInteraction(snapInteraction);\n  }\n}\n\ntypeSelect.onchange = function () {\n  map.removeInteraction(drawInteraction);\n  map.removeInteraction(snapInteraction);\n  addInteraction();\n};\naddInteraction();\n"],"sourceRoot":""}